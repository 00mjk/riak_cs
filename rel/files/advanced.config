[
 {riak_cs,

   [
    %% == Usage recording ==

    %% @doc How often to flush the access log; integer factor of
    %% access_archive_period (1 == once per period; 2 == twice per period,
    %% etc.)
    {access_log_flush_factor, 1},

    %% Additional access log flush trigger - flush after
    %% this many accesses are recorded, even if the flush
    %% interval has not expired; integer number of accesses
    {access_log_flush_size, 1000000},

    %% How large each access archive object is. Should be a
    %% multiple of access_log_flush_interval; integer number
    %% of seconds (3600 == 1 hour)
    {access_archive_period, 3600},

    %% How many access logs are allowed to pile up in the
    %% archiver's queue before it starts skipping to catch
    %% up; integer number of logs
    {access_archiver_max_backlog, 2},

    %% How many workers to put access log data to Riak are
    %% allowed to run concurrently; integer number of workers
    {access_archiver_max_workers, 2},

    %% When to automatically start storage calculation
    %% batches; list of "HHMM" UTC times
    %% ([] == do not automatically calculation;
    %%  ["0600"] == automatically calculate at 6am UTC every day;
    %%  ["0600","1945"] == automatically calculate at 6am and
    %%                     again at 7:45pm every day)
    {storage_schedule, []},

    %% How large each storage archive object is. Should be
    %% chosen such that each storage_schedule entry falls in
    %% a different period; integer number of seconds
    %% (86400 == 1 day)
    {storage_archive_period, 86400},

    %% How many archive periods a user can request in one
    %% usage read, applied independently to access and
    %% storage; integer number of intervals (744 == 1 month
    %% @ 1 hour intervals)
    {usage_request_limit, 744}

   ]}
].
